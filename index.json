{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Explore the APIs | MADE.NET UI",
    "keywords": "Explore the APIs Here you'll find all of the generated code documentation for the MADE.NET UI projects, similar to what you might find on Microsoft Docs! This documentation is designed to show you how each component of MADE.NET UI is constructed and provide a reference for you when building your projects."
  },
  "articles/features/media-image.html": {
    "href": "articles/features/media-image.html",
    "title": "Using the Media Image package | MADE.NET UI",
    "keywords": "Using the Media Image package The Media Image package is designed to be used in applications that require image processing. Loading StorageFile thumbnails into an Image with LoadStorageFileThumbnailImageBehavior The MADE.Media.Image.Behaviors.LoadStorageFileThumbnailImageBehavior is a custom behavior built on the Microsoft XAML behaviors SDK . It can be attached to an Image UI element and used to load the thumbnail of a StorageFile . You can do this in your app XAML as shown below. <Page x:Class=\"App.Media.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:behaviors=\"using:MADE.Media.Image.Behaviors\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:interactivity=\"using:Microsoft.Xaml.Interactivity\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <RelativePanel Padding=\"12\"> <Image> <interactivity:Interaction.Behaviors> <behaviors:LoadStorageFileThumbnailImageBehavior File=\"{x:Bind ViewModel.ImageFile}\" /> </interactivity:Interaction.Behaviors> </Image> </RelativePanel> </Page> This could result in a generated UI that looks like this."
  },
  "articles/features/ui.html": {
    "href": "articles/features/ui.html",
    "title": "Using the UI package | MADE.NET UI",
    "keywords": "Using the UI package The UI package is a base package for building out UI components for native applications for Windows, Android, iOS, macOS, Linux, and the web. Its main purpose is to be used by the additional MADE.NET UI UI packages. However, it can be used to build your own custom UI elements for your own applications. Building custom controls for Windows or Uno Platform applications The MADE.UI.Controls.Control is an extension to the Windows.UI.Xaml.Controls.Control that provides additional base components to make it easier to build custom controls. For detail on building the custom control itself, we highly recommend these resources for information on building them. Nick's .NET Travels - How to create a XAML templated control With this base class, you get the following additional features to work with. IsVisible property IsVisible is a boolean property that controls the Visibility state of the control. When updated, the IsVisibleChanged event is fired which can be used to handle additional functions when a control is shown or hidden. GetChildView{TView} method GetChildView{TView}(string) is a method which sits on top of the GetTemplateChild method of the underlying Control class. The method simplifies the understanding and usability of retrieving child UI elements by retrieving your UI elements in the expected type."
  },
  "articles/features/ui-controls-chipbox.html": {
    "href": "articles/features/ui-controls-chipbox.html",
    "title": "Using the ChipBox control | MADE.NET UI",
    "keywords": "Using the ChipBox control The MADE.UI.Controls.ChipBox element is a custom-built UI element that works with Uno's supported platforms that provides a multi value input for a text box with auto-suggest capabilities. Values added are displayed as removable chips. The control is a familiar custom input style control used in web applications. Shown below is the visuals for the control in its default state, with some chip values already added. Example usage <Page x:Class=\"ChipBoxSample.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:controls=\"using:MADE.UI.Controls\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <RelativePanel Padding=\"12\"> <controls:ChipBox x:Name=\"ChipBoxControl\" Margin=\"0,12,0,0\" Suggestions=\"{x:Bind ChipSuggestions}\" Chips=\"{x:Bind SelectedChips}\" TextChangeCommand=\"{x:Bind SuggestionTextChangeCommand}\" Header=\"ChipBox\" RelativePanel.AlignLeftWithPanel=\"True\" RelativePanel.AlignRightWithPanel=\"True\" RelativePanel.AlignTopWithPanel=\"True\" /> </RelativePanel> </Page> Retrieving added chip values The control exposes the selected chips through the Chips list property. The type of objects contained in this collection will be ChipItem which contains the contents of the item as a generic Object type. This allows the ChipBox control to support any type of input value object. Providing suggestions for chip values The ChipBox provides a Suggestions property that can be used to provide a list of objects that should be displayed to the user as suggestions. The control exposes a TextChangeCommand property and a TextChanged event that can be used to provide the ability to customize and provide relevant suggestions based on the text provided. This is not a baked in feature of the control itself. Here is an example of using this in action. private static readonly IList<string> Places = new List<string> { \"Austria\", \"Belgium\", \"Bulgaria\", \"Croatia\", \"Cyprus\", \"Czechia\", \"Denmark\", \"Estonia\", \"Finland\", \"France\", \"Germany\", \"Greece\", \"Hungary\", \"Ireland\", \"Italy\", \"Latvia\", \"Lithuania\", \"Luxembourg\", \"Malta\", \"Netherlands\", \"Poland\", \"Portugal\", \"Romania\", \"Slovakia\", \"Slovenia\", \"Spain\", \"Sweden\" }; public ICommand SuggestionTextChangeCommand => new RelayCommand<string>(this.OnSuggestionTextChanged); public ObservableCollection<string> ChipSuggestions { get; } = new(Places); private void OnSuggestionTextChanged(string obj) { ChipSuggestions.MakeEqualTo(Places.Where(x => x.Contains(obj, StringComparison.CurrentCultureIgnoreCase))); } It is up to the developer to implement the logic to provide suggestions. This is to ensure any flexibility in search and filtering is determined by the application rather than the control. Customizing the ChipBox The control has many customization properties that are exposed to tailor the experience for your application. HeaderTemplate The Header can be customized to include custom UI elements as well as a string resource. The HeaderTemplate is also available to provide a DataTemplate for you to define the rendered UI for the Header . ChipContentTemplate The rendered UI elements for the chips use a MADE Chip content control. By default, the chips will be rendered displaying the string equivalent of the content provided to it. To customize the layout and display of the chip's content, apply a DataTemplate to the ChipContentTemplate property. SuggestionsItemTemplate As suggestions could be a list of complex objects rather than a simple string, the control provides a SuggestionsItemTemplate property that can be used to provide a DataTemplate for the suggestions that are displayed to the user. IsReadonly The ChipBox has the ability to be rendered in a readonly state. This is useful when you want to display the chips without any user interaction. When enabled, the auto-suggest text box will not be displayed to the user, and the ability to remove chips will be disabled. AllowDuplicate By default, the ChipBox control allows duplicate values to be accepted. The AllowDuplicate property can be used to disable this behavior. AllowFreeText The control supports the ability to allow free text input for chip values, as well as the option to only support selections from the suggestions list. The AllowFreeText property, enabled by default, can be used to control this behavior."
  },
  "articles/features/ui-controls-dropdownlist.html": {
    "href": "articles/features/ui-controls-dropdownlist.html",
    "title": "Using the DropDownList control | MADE.NET UI",
    "keywords": "Using the DropDownList control The MADE.UI.Controls.DropDownList element is a custom-built UI element that works with Uno's supported platforms that provides a selection user experience, allowing a user to select one or multiple items from a list. The control works in a similar way to the ComboBox element in the Windows SDK, with the added extensibility to change modes to select multiple items. Shown below is the visuals for the control in its default state, in a multiple selection mode. Example usage <Page x:Class=\"DropDownListSample.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:controls=\"using:MADE.UI.Controls\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <RelativePanel Padding=\"12\"> <controls:DropDownList x:Name=\"DropDownList\" Header=\"MultiDropDownList\" ItemsSource=\"{x:Bind ViewModel.ItemCollection}\" RelativePanel.AlignLeftWithPanel=\"True\" RelativePanel.AlignRightWithPanel=\"True\" RelativePanel.AlignTopWithPanel=\"True\" SelectionMode=\"Multiple\" /> </RelativePanel> </Page> Customizing the DropDownList The control has many customization properties that are exposed to tailor the experience for your application. HeaderTemplate The Header can be customized to include custom UI elements as well as a string resource. The HeaderTemplate is also available to provide a DataTemplate for you to define the rendered UI for the Header . ItemTemplate and ItemTemplateSelector The rendered UI elements for the items in the control can be customized with the ItemTemplate or ItemTemplateSelector . SelectionMode The DropDownList has two selection modes, Single and Multiple . By default, the control works in a Single selection mode. MaxDropDownHeight The height of the drop-down can be customized to allow you to show more results that the default expanded view. By default, the drop down will expand to 248 pixels."
  },
  "articles/features/ui-controls-filepicker.html": {
    "href": "articles/features/ui-controls-filepicker.html",
    "title": "Using the FilePicker control | MADE.NET UI",
    "keywords": "Using the FilePicker control The MADE.UI.Controls.FilePicker element is a custom-built UI element that works with Uno's supported platforms that provides a file selection user experience. The control works in a similar way to the <input type=\"file\" /> element in web applications. Shown below is the visuals for the control in its default state, in a multiple selection mode. Example usage <Page x:Class=\"FilePickerSample.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:controls=\"using:MADE.UI.Controls\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <RelativePanel Padding=\"12\"> <controls:FilePicker x:Name=\"FilePickerControl\" Margin=\"0,12,0,0\" AppendFiles=\"True\" Files=\"{x:Bind FilePickerFiles}\" Header=\"FilePicker\" RelativePanel.AlignLeftWithPanel=\"True\" RelativePanel.AlignRightWithPanel=\"True\" RelativePanel.AlignTopWithPanel=\"True\" SelectionMode=\"Multiple\" /> </RelativePanel> </Page> Retrieving selected files The control exposes the selected files through the Files list property. The type of objects contained in this collection will be FilePickerItem which contains the details for the file including: The file as a StorageFile The thumbnail as a BitmapImage The file name including the extension The display name The file type The file path Customizing the FilePicker The control has many customization properties that are exposed to tailor the experience for your application. HeaderTemplate The Header can be customized to include custom UI elements as well as a string resource. The HeaderTemplate is also available to provide a DataTemplate for you to define the rendered UI for the Header . ChooseFileButtonContent and ChooseFileButtonContentTemplate The ChooseFileButtonContent can be used to set the UI elements or string resource displayed on the button. The rendered UI elements for the button content in the control can also be customized with the ChooseFileButtonContentTemplate . SelectionMode The FilePicker has two selection modes, Single and Multiple . By default, the control works in a Single selection mode. FileTypes When the user selects the button to choose files, you can customize what files can be selected using a list of file extensions with the FileTypes property. By default, the control will allow any file to be selected using the * selector. AppendFiles If multiple selection is enabled, the AppendFiles boolean flag will allow your user to append additional files to the existing selections if they choose to add more files. By default, this is false which will overwrite the files chosen on subsequent additions. ItemsViewStyle The ItemsViewStyle controls the styling applied to the view which displays the selected items. The default user experience styling is shown at the top of this article."
  },
  "articles/features/ui-controls-richedittoolbar.html": {
    "href": "articles/features/ui-controls-richedittoolbar.html",
    "title": "Using the RichEditToolbar control | MADE.NET UI",
    "keywords": "Using the RichEditToolbar control The MADE.UI.Controls.RichEditToolbar element is a custom-built UI element that works with Uno's supported platforms that provides customizable and extensible collection of buttons that activate rich text features in an associated RichEditBox . Shown below is the visuals for the control in its default state. Example usage <Page x:Class=\"ChipBoxSample.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:controls=\"using:MADE.UI.Controls\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:win=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <Grid> <Grid.RowDefinitions> <RowDefinition Height=\"Auto\" /> <RowDefinition Height=\"*\" /> </Grid.RowDefinitions> <controls:RichEditToolbar x:Name=\"RichEditToolbarControl\" TargetRichEditBox=\"{x:Bind RichEditBox}\" ShowFontSizeOptions=\"True\" ShowTextColorOptions=\"True\" ShowListStyleOptions=\"True\"> <controls:RichEditToolbar.CustomOptions> <AppBarSeparator /> <AppBarButton x:Name=\"SaveButton\" Icon=\"Save\" Label=\"Save\" /> <AppBarButton x:Name=\"UndoButton\" Icon=\"Undo\" Label=\"Undo\" /> <AppBarButton x:Name=\"RedoButton\" Icon=\"Redo\" Label=\"Redo\" /> </controls:RichEditToolbar.CustomOptions> </controls:RichEditToolbar> <win:RichEditBox x:Name=\"RichEditBox\" Grid.Row=\"1\" /> </Grid> </Page> Supporting Uno Platform Unfortunately, Uno Platform doesn't currently support the use of RichEditBox . The control has been custom built now to structure around the unsupported direct attachment to a RichEditBox exposing events that allow a developer to use the control in a different context in Uno Platform applications. You can listen for these changes by hooking onto the following RichEditToolbar events: FontSizeChanged FontStyleChanged TextColorChanged ListStyleChanged These are fired when the user changes the font size, font style, text color, or list style. Each event provides an event argument that provides the new values for that setting. Customizing the ChipBox The control has many customization properties that are exposed to tailor the experience for your application. Custom toolbar options As well as the out-of-the-box options available, the RichEditToolbar allows developers to extend the options with additional custom options. These can be added to the CustomOptions collection on the control either via XAML or in code. <controls:RichEditToolbar> <controls:RichEditToolbar.CustomOptions> <AppBarButton x:Name=\"SaveButton\" Icon=\"Save\" Label=\"Save\" /> <AppBarButton x:Name=\"UndoButton\" Icon=\"Undo\" Label=\"Undo\" /> <AppBarButton x:Name=\"RedoButton\" Icon=\"Redo\" Label=\"Redo\" /> </controls:RichEditToolbar.CustomOptions> </controls:RichEditToolbar> Custom text color options Exposed on the RichEditToolbar is a CustomTextColorOptions property that allows you to provide your own custom set of colors to display in the text color options panel. Here's an example of adding these via code. private static readonly IList<RichEditToolbarTextColorOption> CustomTextColorOptions = new List<RichEditToolbarTextColorOption> { new() {Name = \"Pastel pink\", Color = \"#ff80ff\"}, new() {Name = \"Pastel orange\", Color = \"#ffc680\"}, new() {Name = \"Pastel yellow\", Color = \"#ffff80\"}, new() {Name = \"Pastel green\", Color = \"#80ff9e\"}, new() {Name = \"Pastel blue\", Color = \"#80d6ff\"}, new() {Name = \"Pastel purple\", Color = \"#bcb3ff\"}, }; this.RichEditToolbar.CustomTextColorOptions = this.CustomTextColorOptions; Showing font size options By default, font size options are shown to the user when using the control out-of-the-box. If these options are not desired, set the ShowFontSizeOptions property to False . Showing text color options By default, text color options are shown to the user when using the control out-of-the-box. If these options are not desired, set the ShowTextColorOptions property to False . Showing list style options By default, list style options are shown to the user when using the control out-of-the-box. If these options are not desired, set the ShowListStyleOptions property to False ."
  },
  "articles/features/ui-controls-validator.html": {
    "href": "articles/features/ui-controls-validator.html",
    "title": "Using the InputValidator control | MADE.NET UI",
    "keywords": "Using the InputValidator control The MADE.UI.Controls.InputValidator element is a custom-built UI element wrapper for input controls that works with Uno's supported platforms that provides an input validation experience. Shown below is the visuals for the control in its default state validating a TextBox and DatePicker with input validators from the MADE.Data.Validation library. Example usage <Page x:Class=\"InputValidatorSample.MainPage\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:controls=\"using:MADE.UI.Controls\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" mc:Ignorable=\"d\"> <RelativePanel Padding=\"12\"> <controls:InputValidator x:Name=\"TextBoxValidator\" Margin=\"0,12,0,0\" Input=\"{x:Bind TextBox.Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" RelativePanel.AlignLeftWithPanel=\"True\" RelativePanel.AlignRightWithPanel=\"True\" RelativePanel.AlignTopWithPanel=\"True\"> <TextBox x:Name=\"TextBox\" Header=\"TextBox with InputValidator\" /> </controls:InputValidator> <controls:InputValidator x:Name=\"DatePickerValidator\" Margin=\"0,12,0,0\" Input=\"{Binding SelectedDate, Mode=TwoWay, ElementName=DatePicker, UpdateSourceTrigger=PropertyChanged}\" RelativePanel.AlignLeftWithPanel=\"True\" RelativePanel.AlignRightWithPanel=\"True\" RelativePanel.Below=\"TextBoxValidator\"> <DatePicker x:Name=\"DatePicker\" Header=\"DatePicker with InputValidator\" /> </controls:InputValidator> </RelativePanel> </Page> namespace InputValidatorSample { using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Diagnostics; using global::Windows.UI.Xaml.Controls; using MADE.Data.Validation; using MADE.Data.Validation.Validators; using MADE.UI.Controls; public sealed partial class MainPage : Page { public MainPage() { this.InitializeComponent(); this.TextBoxValidator.Validators = new ValidatorCollection { new RequiredValidator(), new EmailValidator(), }; this.DatePickerValidator.Validators = new ValidatorCollection { new RequiredValidator(), new BetweenValidator(DateTimeOffset.Now, DateTimeOffset.Now.AddDays(7)), }; } } } Validating an input The InputValidator is designed in a way that it can be used with any input control, whether in-built like TextBox or custom-built like the MADE FilePicker control. Simply, the Input property of the validator needs to be bound to the input value reference from the wrapped input control that needs to be validated. You can then provide a ValidatorCollection instance from the Data Validation package , containing the IValidator instances that will be run on the input. This can either be a bound property in your view-model, set in your view code-behind, or defined in your XAML as a static resource. The implementation of using IValidator instances allows you to dynamically configure your validators based on other criteria of your view. For example, you might want to validate two DatePicker controls that define a min/max range. The validator for the maximum date could be dynamically updated so that its minimum value is defined based on the value of the minimum date picker. Extending input validation for your application's needs The validation of the InputValidator is based on IValidator instances from the Data Validation package. While the package provides a common set of validators for basic scenarios such as required, range, min, max, and email, you can create your own. Find more detail on creating your own custom IValidator types in our Data Validation article . Customizing the InputValidator The control has many customization properties that are exposed to tailor the experience for your application. FeedbackMessageStyle The FeedbackMessageStyle controls the styling applied to the TextBlock that displays the validator messages. The default user experience styling is shown at the top of this article."
  },
  "articles/features/ui-data-converters.html": {
    "href": "articles/features/ui-data-converters.html",
    "title": "Using the UI Data Converters package | MADE.NET UI",
    "keywords": "Using the UI Data Converters package The UI Data Converters package is designed for making the conversion of data objects to a different type in native applications for Windows, Android, iOS, macOS, Linux, and the web easier. Converting boolean values to a string (and back) with the BooleanToStringValueConverter The MADE.UI.Data.Converters.BooleanToStringValueConverter provides a way to convert a boolean value to a string and back with a bound data source in a XAML view. <Grid> <Grid.Resources> <converters:BooleanToStringValueConverter x:Key=\"BooleanToStringValueConverter\" TrueValue=\"Yes\" FalseValue=\"No\" /> </Grid.Resources> <!-- A true boolean will return the TrueValue of the converter --> <TextBlock Text=\"{x:Bind ViewModel.True, Converter={StaticResource BooleanToStringValueConverter}}\" /> <!-- A false boolean will return the FalseValue of the converter --> <TextBlock Text=\"{x:Bind ViewModel.False, Converter={StaticResource BooleanToStringValueConverter}}\" /> </Grid> Instances of the converter can be set up with varying values for the TrueValue and FalseValue properties that will represent the value shown when the boolean is true and false, respectively. The default values are Yes and No . Note , when converting back from the string value to a boolean when used in a TwoWay binding, the TrueValue and FalseValue properties are used to determine which value is considered true and false. If the string value does not match, an exception will be thrown. Displaying a byte array as an image with the ByteArrayToImageSourceValueConverter The MADE.UI.Data.Converters.ByteArrayToImageSourceValueConverter provides a way to convert a bound byte array containing the details of an image to an image source that can be bound to an Image XAML element. <Grid> <Grid.Resources> <converters:ByteArrayToImageSourceValueConverter x:Key=\"ByteArrayToImageSourceValueConverter\" /> </Grid.Resources> <!-- Converts the image's byte array into a source image that is loaded into the element --> <Image Source=\"{x:Bind ViewModel.ImageBytes, Converter={StaticResource ByteArrayToImageSourceValueConverter}, Mode=OneWay}\" /> </Grid> Formatting a DateTime value with the DateTimeToStringValueConverter The MADE.UI.Data.Converters.DateTimeToStringValueConverter converts a given DateTime object into a string using the provided format in the binding ConverterParameter property. <Grid> <Grid.Resources> <converters:DateTimeToStringValueConverter x:Key=\"DateTimeToStringValueConverter\" /> </Grid.Resources> <!-- Converts the DateTime object into the dd/MM/yyyy format --> <TextBlock Text=\"{x:Bind ViewModel.DateTime, Converter={StaticResource DateTimeToStringValueConverter}, ConverterParameter=dd/MM/yyyy}\" /> </Grid> Note , the converter supports any of the standard and custom formats supported by the DateTime.ToString() method. You can find more information on these in the Microsoft documentation ."
  },
  "articles/features/ui-styling.html": {
    "href": "articles/features/ui-styling.html",
    "title": "Using the UI Styling package | MADE.NET UI",
    "keywords": "Using the UI Styling package The UI Styling package is designed for improving the flow of designing native applications for Windows, Android, iOS, macOS, Linux, and the web. Converting HEX strings to colors and SolidColorBrush with ColorExtensions The MADE.UI.Styling.Colors.ColorExtensions provides a collection of extensions that can be used to manipulate System.Drawing.Color , Windows.UI.Color or Windows.UI.Xaml.Media.SolidColorBrush objects such as converting a HEX value to them and back. Below are some example usages for your applications built for Windows and the Uno Platform. Convert HEX String to Color and back example private void HexColorConversion() { Windows.UI.Color redWindowsColor = \"#FF0000\".ToWindowsColor(); System.Drawing.Color redSystemColor = \"#FF0000\".ToSystemColor(); string redHex = redColor.ToHexString(); // or redSystemColor.ToHexString(); } Note , the ToColor() extension for HEX strings supported both RGB and ARGB formats, taking into consideration the transparency layer. Convert Color to SolidColorBrush example private void ColorSolidColorBrushConversion() { SolidColorBrush redBrush = Windows.UI.Colors.Red.ToSolidColorBrush(); // or System.Drawing.Color.Red.ToSolidColorBrush(); }"
  },
  "articles/features/ui-view-management.html": {
    "href": "articles/features/ui-view-management.html",
    "title": "Using the UI View Management package | MADE.NET UI",
    "keywords": "Using the UI View Management package The UI View Management package is designed for improving how your applications can create and manage additional windows in Windows applications. Creating a new application window with a Page type Windows application developers working with a navigation Frame will be aware of the ease of use for navigating your applications with Page object types. You can simply call Navigate passing a parameter object. So why shouldn't creating a new window follow the same way. The WindowManager helper class provides a CreateNewWindowForPageAsync method with multiple overloads with this exact capability. Below is an example of launching a new application window with a page type. private async Task LaunchNewWindow() { await WindowManager.CreateNewWindowForPageAsync(typeof(MainPage), \"ParameterObject\"); } This example will launch a new Window with an initial page showing the MainPage , passing the string as a page navigation parameter. Accessing the window's CoreDispatcher When a new window is launched using the CreateNewWindowForPageAsync methods, the view's CoreDispatcher instance will be registered with the ViewCoreDispatcherManager instance. This can be accessed from anywhere in your application's executing code using the ViewCoreDispatcherManager.Current.Get method passing the identifier of the view. To keep an instance of the view ID associated with your page, when initializing your page class, you can retrieve the view ID using the following code. public MainPage() { var view = ApplicationView.GetForCurrentView(); this.ViewId = view?.Id ?? -1; } public int ViewId { get; }"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Getting Started | MADE.NET UI",
    "keywords": "Getting Started MADE.NET UI is a collection of components designed for building applications with the Uno Platform on Windows, Android, iOS, and WebAssembly. Installation All packages listed below can be installed via NuGet or via the dotnet CLI by running the following command using a listed package name: dotnet add package MADE.UI Available packages Package Version MADE.Media.Image MADE.UI MADE.UI.Controls.ChipBox MADE.UI.Controls.DropDownList MADE.UI.Controls.FilePicker MADE.UI.Controls.RichEditToolbar MADE.UI.Controls.Validator MADE.UI.Data.Converters MADE.UI.Styling MADE.UI.ViewManagement Media.Image The Media Image package is designed to be used in applications that require image processing. It provides capabilities, such as: LoadStorageFileThumbnailImageBehavior, a XAML behavior for loading a thumbnail from a StorageFile on an Image element. Discover Media.Image UI The UI package is a base library for building out great user experiences for applications built for Windows, Android, iOS, and the web. Taking advantage of the Uno Platform, the UI packages provide extensible features such as: Control, a base implementation on top of the XAML Control type with additional functionality such as IsVisible (to get and set the state of the control's visibility), and GetChildView (to find and retrieve a UI element which is a child of the element). ContentControl, a base implementation on top of the XAML ContentControl type with additional functionality such as IsVisible (to get and set the state of the control's visibility), and GetChildView (to find and retrieve a UI element which is a child of the element). ViewExtensions, a collection of extensions for manipulating XAML UIElement objects including SetVisible (to toggle the visible state of the element and child elements). Discover UI UI.Controls.ChipBox The UI Controls ChipBox library contains a cross-platform UI element that provides a multi value input for a text box with auto-suggest capabilities. Values added are displayed as removable chips. Discover UI.Controls.ChipBox UI.Controls.DropDownList The UI Controls DropDownList library contains a Windows UI element that provides a selection user experience, allowing a user to select one or multiple items from a list. The control works in a similar way to the ComboBox element in the Windows SDK, with the added extensibility to change modes to select multiple items. Discover UI.Controls.DropDownList UI.Controls.FilePicker The UI Controls FilePicker library contains a cross-platform UI element that provides a web-like <input type=\"file\" /> equivalent for native applications. The control provides the capability to select one or multiple files of given types and show them within the UI. Discover UI.Controls.FilePicker UI.Controls.RichEditToolbar The UI Controls RichEditToolbar library contains a cross-platform UI element that provides customizable and extensible collection of buttons that activate rich text features in an associated RichEditBox. Think the InkToolbar equivalent for RichEditBox controls! Discover UI.Controls.RichEditToolbar UI.Controls.Validator The UI Controls Validator library contains a cross-platform UI element that provides validation capabilities over any input element. Taking advantage of the Data Validation library, you can simply and easily setup input validation with error messaging for all input types, both built-in and custom, with minimal effort. Discover UI.Controls.Validator UI.Data.Converters The UI Data Converters package is designed for making the conversion of data objects to a different type in native applications for Windows, Android, iOS, macOS, Linux, and the web easier. Discover UI.Data.Converters UI.Styling The UI Styling library contains a collection of cross-platform UI styling components for improving the designing of applications. Discover UI.Styling UI.ViewManagement The UI View Management package is designed for improving how your applications can create and manage additional windows in Windows applications. Discover UI.ViewManagement"
  },
  "index.html": {
    "href": "index.html",
    "title": "Make App Development Easier | MADE.NET UI",
    "keywords": "Make app development easier with reusable code MADE.NET UI is a collection of components designed for building applications with the Uno Platform on Windows, Android, iOS, and WebAssembly. Learn more Supports Windows UWP, WinUI Android 10.0+ iOS 10.0+ macOS Unified API Web WebAssembly (WASM) Stats v1.5.0 Latest release 300k+ Total downloads 27 NuGet packages UI Components MADE.NET UI provides a set of cross-platform UI components for Windows, WebAssembly, Android, iOS, macOS, and Linux. Get data validation in seconds MADE provides a lightweight, extensible data validation wrapper for input components in your applications Use the .NET Color you prefer Easy-to-use extensions for System.Drawing.Color and Windows.UI.Color to simplify the styling of your applications Manage application windows Save time building multi-window applications with the WindowManager, designed to simplify the creation of new application windows Easy cross-platform page-to-page navigation Ease your approach to cross-platform page-to-page navigation using MADE's page navigation service built on top of the MVVM Toolkit MADE.NET UI is simple to install and it's easy to get started. Learn more Support MADE.NET UI If you'd like to support MADE.NET UI, considering donating to the project Support MADE.NET UI Contribute on GitHub MADE.NET UI is open source and you can contribute on GitHub Contribute to MADE.NET UI"
  },
  "README.html": {
    "href": "README.html",
    "title": "MADE.NET UI Documentation | MADE.NET UI",
    "keywords": "MADE.NET UI Documentation This folder contains source code for the generation of MADE.NET UI's documentation. Contributing to the docs Install dependencies Download and install docfx on your computer. MacOS brew install docfx Windows choco install docfx Running locally docfx .\\docfx.json --serve This will run the docs on http://localhost:8080"
  }
}